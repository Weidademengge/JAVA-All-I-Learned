## 一、多线程基本概念和好处：

### 1.程序(program)

程序是为完成特定任务、用某种语言编写的一组指令的集合。即指一 段静态的代码，静态对象。

### 2.进程(process)

-   **是程序的一次执行过程，或是正在运行的一个程序。**是一个动态 的过程：有它自身的产生、存在和消亡的过程。
-   如：运行中的QQ，运行中的MP3播放器
-   进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域

### 3.线程(thread)

-   **进程可进一步细化为线程**，是一个程序内部的一条执行路径。
-   若一个进程同一时间并行执行多个线程，就是支持多线程的。
-   线程作为调度和执行的单位，**每个线程拥有独立的运行栈和程序计数器(pc)**。
-   **一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象，可以 访问相同的变量和对象**。这就使得线程间通信更简便、高效。
-   **一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc() 垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。**

### 3.多线程的好处：

-   提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
-   提高计算机系统CPU的利用率
-   改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和 修改。

## 二、多线程的创建和使用

### 1.Thread类

**构造器：**

-   Thread（）：创建新的Thread对象
-   Thread（String threadname）：创建线程并指定线程实例名
-   Thread（Runnable target）：指定创建线程的目标对象，它实现了Runnable接 口中的run方法
-   Thread（Runnable target， String name）：创建新的Thread对象

### 2.创建线程的四种方式：

#### （一）继承Thread类

1.  **步骤：**

1) 定义子类继承Thread类。

2) 子类中重写Thread类中的run方法。

3) 创建Thread子类对象，即创建了线程对象。

4) 调用线程对象start方法：启动线程，调用run方法。

-   通过此对象调用start（）:①启动当前线程 ② 调用当前线程的run()
-   注意：不能通过直接调用run()的方式启动线程。

2.  **创建匿名子类对象**

有时候可能该线程只使用一次，就可以不必去创建子类。

```java
new Thread(){
           @Override
           public void run() {
                     方法体
               }
           }
 }.start();
```

#### （二）实现Runnable接口

1.  **步骤：**

1) 定义子类，实现Runnable接口。

2) 子类中重写Runnable接口中的run方法。

3) 通过Thread类含参构造器创建线程对象。

4) 将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。

5) 调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。

2.  **好处：**

-   避免了单继承的局限性
-   多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。

#### （三）实现Callable接口

看课件，其实视频讲多线程的都很简单基础，需要去看看高并发深入学习一下。

#### （四）使用线程池

### 3.Thread类的有关方法

-   **void start()**：启动线程，并执行对象的run()方法
-   **run()**：线程在被调度时执行的操作
-   **String getName()**：返回线程的名称
-   **void setName(String name)：**设置该线程名称
-   **static Thread currentThread()**：返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类
-   **static void yield()**：线程让步

-   暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程
-   若队列中没有同优先级的线程，忽略此方法

-   **join()**：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止 。低优先级的线程也可以获得执行。
-   **static void sleep(long millis)**：(指定时间:毫秒)

-   令当前活动线程在指定时间段内放弃对CPU控制，使其他线程有机会被执行，时间到后重排队。
-   抛出InterruptedException异常

-   **stop()：**强制线程生命期结束（过时了，不建议使用）
-   **boolean isAlive()**：返回boolean，判断线程是否还活着

### 4.线程优先级

1.  **线程优先级一共有十档**

-   MAX_PRIORITY：10
-   MIN _PRIORITY：1
-   NORM_PRIORITY：5

2.  **涉及的方法：**

-   **getPriority()** ：返回线程优先值
-   s**etPriority（int newPriority）** ：改变线程的优先级

3.  **说明：**

-   线程创建时继承父线程的优先级
-   低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用

### 5.线程的分类

Java中的线程分为两类：一种是守护线程，一种是用户线程。

-   它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。
-   守护线程是用来服务用户线程的，通过在start()方法前调用 thread.setDaemon(true)可以把一个用户线程变成一个守护线程。
-   main（）就是一个用户线程，gc（）垃圾回收线程就是一个守护线程。
-   若JVM中都是守护线程，当前JVM将退出。

## 三、线程的生命周期

1.  JDK中用 **Thread.State类** 定义了线程的几种状态。
2.  **要想实现多线程，必须在主线程中创建新的线程对象。**Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：

-   **新建：** 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建 状态。
-   **就绪：**处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已 具备了运行的条件，只是没分配到CPU资源 。
-   **运行：**当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线 程的操作和功能 。
-   **阻塞：**在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中 止自己的执行，进入阻塞状态 。
-   **死亡：**线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束。

![](https://cdn.nlark.com/yuque/0/2021/png/12612984/1614585509764-8248c6ff-191f-43b4-ae8e-faac07f9b250.png)

## 四、线程的同步

![](https://cdn.nlark.com/yuque/0/2021/png/12612984/1614602828943-db8c79fe-c8c4-415f-95d4-1fb16c76a234.png)

**解决思路：**

当线程a操作共享数据时，其他线程不能够参与进来，直到线程a操作完毕，其他线程才可以操作。即使线程a出现了阻塞，也不能改变。

### 一、三种解决方式：

#### 1.方式一：同步代码块

synchronized(同步监视器)

｛

//需要同步的代码

｝

同步监视器：又称锁。任何一个对象都可以充当锁。但是有一个要求：多个线程必须共用同一把锁，言外之意就是不能直接new一个匿名对象传进去。

示例：

```java
public class ThreadTest1 {
    public static void main(String[] args) {
        MThread mythread=new MThread();

        Thread thread1=new Thread(mythread);
        Thread thread2=new Thread(mythread);
        Thread thread3=new Thread(mythread);
        thread1.start();
        thread2.start();
        thread3.start();
    }
}
class MThread implements Runnable
{
    private int ticket=100;
    private Object obj=new Object();
    public void run()
    {
        while(true)
        {
            synchronized (this) {
                if(ticket>0) {
                    System.out.println(Thread.currentThread().getName() + ":" + ticket);
                    ticket--;
                }
                else break;
            }
        }
    }
}
```

如果是使用继承Thread的方式，有个地方需要注意：

![](https://cdn.nlark.com/yuque/0/2021/png/12612984/1614610666140-798ebb46-8ea2-45e3-aaac-600c6b122983.png)

#### 2.方式二：同步方法

如果操作共享数据的代码完整地声明在一个方法内，可以将此方法声明为同步。

#### 3.方式三：Lock锁

```java
public class LockTest
{
    public static void main(String[] args) {
        Window w=new Window();
        Thread t1=new Thread(w);
        Thread t2=new Thread(w);

        t1.start();
        t2.start();
    }


}
class Window implements Runnable{
    private int ticket=100;
    //第一步：new一个lock对象
    private ReentrantLock lock=new ReentrantLock();

    @Override
    public void run() {
        while(true)
        {
            try {
                //第二步：调用锁定方法lock()
                lock.lock();
                if(ticket>0)
                {   
                    System.out.println(Thread.currentThread().getName()+":"+ticket);
                    ticket--;
                }
                else break;
            }finally {
                //第三步：调用解锁方法unlock()
                lock.unlock();
            }

        }
    }
}
```

#### 4.面试题：synchronized和Lock锁的异同？

相同点：二者都可以解决线程安全问题。

不同点：synchronized在执行完相应的同步代码块后，自动释放同步监视器。

Lock需要手动启动同步，手动结束同步。

### 二、同步的好处和坏处

好处：解决了线程安全问题

坏处：操作同步代码时，只能有一个线程参与，其他线程等待，相当于一个单线程的过程，效率低。

## 五、线程的通信

通过例子引入：使用两个线程打印 1-100。线程1, 线程2 交替打印

```java
public class CommunicationTest {
    public static void main(String[] args) {
        Number num=new Number();
        Thread t1=new Thread(num);
        Thread t2=new Thread(num);

        t1.start();
        t2.start();
    }
}
class Number implements Runnable
{
    private int number=1;

    @Override
    public void run() {
        while(true)
        {
            synchronized(this) {
                notifyAll();  //将其他堵塞的线程解除堵塞
                if (number <= 100) {
                    System.out.println(Thread.currentThread().getName() + ":" + number);
                    number++;
                    try {
                        wait();  //该线程进入堵塞状态，同时释放锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                } else break;
            }
        }
    }
}
```

**涉及到的三个方法：**

-   wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。
-   notify()：一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。
-   notifyAll()：一旦执行此方法，就会唤醒所有被wait的线程。

**说明：**

-   1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。
-   2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则，会出现IllegalMonitorStateException异常。也就是说如果同步监视器使用其他类对象，而却用默认的this调用这三个方法，则会抛异常。
-   3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。所以任何一个同步监视器都可以调用这三个方法。

**面试题：sleep() 和 wait()的异同？**

1.  相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。
2.  不同点：

-   两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()
-   调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中
-   关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。

**线程通信的应用：经典例题：生产者/消费者问题**

生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。

分析：

1.  是否是多线程问题？是，生产者线程，消费者线程
2.  是否有共享数据？是，店员（或产品）
3.  如何解决线程的安全问题？同步机制,有三种方法
4.  是否涉及线程的通信？是

```java
class Clerk{
    private int productCount = 0;
    //生产产品
    public synchronized void produceProduct() {

        if(productCount < 20){
            productCount++;
            System.out.println(Thread.currentThread().getName() + ":开始生产第" + productCount + "个产品");

            notify();

        }else{
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
    //消费产品
    public synchronized void consumeProduct() {
        if(productCount > 0){
            System.out.println(Thread.currentThread().getName() + ":开始消费第" + productCount + "个产品");
            productCount--;

            notify();
        }else{
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}
class Producer extends Thread{//生产者

    private Clerk clerk;

    public Producer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(getName() + ":开始生产产品.....");

        while(true){

            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            clerk.produceProduct();
        }

    }
}
class Consumer extends Thread{//消费者
    private Clerk clerk;

    public Consumer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(getName() + ":开始消费产品.....");

        while(true){

            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            clerk.consumeProduct();
        }
    }
}

public class ProductTest {

    public static void main(String[] args) {
        Clerk clerk = new Clerk();

        Producer p1 = new Producer(clerk);
        p1.setName("生产者1");

        Consumer c1 = new Consumer(clerk);
        c1.setName("消费者1");
        Consumer c2 = new Consumer(clerk);
        c2.setName("消费者2");

        p1.start();
        c1.start();
        c2.start();

    }
}
```