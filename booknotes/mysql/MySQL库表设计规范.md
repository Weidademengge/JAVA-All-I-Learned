# 设计规范

## 表设计
表必须定义主键，**默认为ID，整型自增**，如果不采用默认设计必须咨询DBA进行设计评估

ID字段作为自增主键，**禁止在非事务内作为上下文作为条件进行数据传递**，**禁止非自增非数字类型主键设计出现**

**禁止使用外键**，触发器，存储过程

多表中的相同列，必须保证列定义一致

表默认使用InnoDB，国内表字符集默认使用utf8mb4，国际默认使用utf8的表

表必须包含**gmt_create**和**gmt_modified**字段，即表必须包含记录创建时间和修改时间的字段

单表一到两年内数据量超过500w或数据容量超过10G考虑分表，且需要提前考虑历史数据迁移或应用自行删除历史数据

单条记录大小禁止超过8k（列长度(中文)*2（gbk）/3(utf8)+列长度(英文)*1）

日志类数据不建议存储在MySQL上，优先考虑Hbase或OB，如需要存储请找DBA评估使用压缩表存储

主键不允许修改，如特殊需求，需要提前一个月和DBA沟通方案  
  
绝对禁止使用MySQL保留关键字作为表名、列名、索引名等  
  
可变长度设计(例如varchar)一定要按照需要设计，同时控制单行长度，如果过大会降低数据库Buffer命中率，导致更新、查询性能下降

## 字段设计

1) 表被索引列必须定义为not null，并设置default值

2) 禁止使用float、double类型，建议使用decimal替代

3) **禁止使用blob、text类型保留大文本、文件、图片**，建议使用其他方式存储（TFS/SFS/OSS），数据库(MySQL/Oracle)只保存指针信息

4) 禁止使用varchar类型作为主键语句设计

## 索引设计

1) 索引根据**左前缀原则**，当建立一个联合索引(a,b,c)，则查询条件里面只有包含(a)或(a,b)或(a,b,c)的时候才能走索引，(a,c)作为条件的时候只能使用到a列索引，所以这个时候要确定a的返回列一定不能太多，不然语句设计就不合理，(b,c)则不能走索引  
2) 索引不是越多越好，越多的索引带来的就是更高的索引维护成本，包含CPU计算消耗，索引建立时增加的IO开销等，因此一定要合理建立索引  
3) 联合索引应该选择筛选性更优的列值放在最前面，比如单号、userid等，**type，status等筛选性一般的不建议放在最前面**

## 语句设计

1) 如果更新大量数据，可以采用两种方式：  
	a) update tb set column='Yes' where col2='Init' limit 100;  
	b)先select id from tb where col2='Init' limit 10000;

然后循环做update tb ser column='Yes' where id in (xx,xx,xx,xx)，这里in值需要控制一定的数量，平时比较推荐的是200个id一条SQL

2) 禁止使用非同类型的列进行等值查询！

## 其他

1) 禁止使用：存储过程、触发器、函数、视图、事件等MySQL高级功能

2) 禁止使用跨库查询

3) 禁止使用子查询，建议将子查询转换成关联查询

4) 禁止核心业务流程SQL包含：计算操作、多表关联、表遍历case when等复杂查询，建议拆分成单表简单查询

5) varchar长度设计需要根据业务实际需要进行长度控制，**禁止预留过长空间**。例如status使用varchar(128)进行存储。原因是varchar类型虽然对于存储是根据实际长度进行存储，但内存分配则是根据指定长度进行分配，因此不合理的长度设计会导致内存的不合理占用

# 知识点

## varchar 存储规则

-   4.0版本以下，varchar(20)，指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节）
-   5.0版本以上，varchar(20)，指的是20字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放20个，最大大小是65532字节

## varchar 和 char 的区别

char是一种固定长度的类型，varchar则是一种可变长度的类型，它们的区别是：

-   char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足。（在检索操作中那些填补出来的空格字符将被去掉）
-   在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节。（即总长度为L+1字节）