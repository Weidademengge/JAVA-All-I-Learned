  

## JVM的弊端  
JVM实现了跨平台，使得一次编译即可到处运行，但是詹姆斯·高斯林没有跟你说的是，应用运行之前要先启动JVM虚拟机，然后还要加载一大批的类、并做链接和初始化等步骤，而使得光启动一个JVM就得花一大把时间，JVM启动完之后才能执行应用程序本身的启动工作，比如启动Spring容器、启动Tomcat等等。  
  
在一些场景下，集群需要做动态扩缩容，这个动作当然是越快越好，不可能请求过来了，花了半天时间来启动应用，等应用启动完，客户端那边都已经超时了。  
  
特别像目前也比较火的FaaS，更加需要应用程序能快速的启动。  
  

## GraalVM与Go  
所以，近几年来，Go语言火了，Go语言是一种编译型语言，我们需要先把Go代码直接编译成为一个二进制执行文件，比如windows上的exe文件，然后直接运行exe文件就能快速启动程序。  
  
如果说，十年前，Spring是Java的春天，那现在GraalVM就是Java的救世主，Java要想不被Go挤掉，整个Java生态都要向GraalVM靠齐。  
  
GraalVM提供了很多功能，其中一个功能就是能把Java代码直接编译成为二进制文件，比如exe文件，从而使得Java程序也能够快速启动。  
  

## GraalVM与Docker  
目前，大部分Java应用应该都是运行在Docker容器中，这就需要Docker容器中也要安装JDK或JRE，但是如果利用GraalVM将Java应用编译成为了exe文件，那么我们就可以直接把exe文件打成一个Docker镜像了，从而不需要在Docker中按照JDK了，这样将使得Docker容器更加小巧，也更加适应自动扩缩容。  
  

## GraalVM的缺点与未来  
GraalVM为了把Java程序编译为一个可执行的二进制文件，需要预先确定程序中用到的所有类，但是Java程序中很有可能某些类是动态生成的，比如很多框架中都用到了动态代理，从而程序运行过程中会动态生成一些类。  
  
为了解决这个问题，比较笨的办法是，通过配置文件指定哪些类是动态生成的，比较聪明的办法是，先运行一下程序自动找到哪些类是动态生成的。  
  
GraalVM这两种办法都是支持的，这样对于Spring、SpringBoot这些框架就能省事很多了，  
  
这样，对于一个SpringBoot应用程序，就可以利用GraalVM将它编译成为一个可执行的二进制文件了。  
  
当然，Spring及SpringBoot为了进一步提升启动速度，Spring及SpringBoot自身也做了一些优化，比如Spring AOT将Bean扫描转移到了编译期来做，从而能进一步提升启动速度。  
  