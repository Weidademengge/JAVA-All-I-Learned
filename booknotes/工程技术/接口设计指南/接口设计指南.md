## 引言

我们在设计一个大容量交互系统时，通常会将系统做一定分解，以降低分析设计开发的难度。在这些分解方法中，模块划分是一个比较常见的方式。 而在模块的划分及其分析设计的实践中，模块和模块的交互接口最为重要，通常我们认为这些接口应该保持通用，稳定，向下兼容性，然而如何设计出一个良好的模块对外提供的接口却是一个不易的问题。

我们一般从如下方面来分析接口设计的特点：

1. 接口的隔离性: 客户端不应该强行依赖它不需要的接口，这一部分主要描述模块设计和接口的关系。

2. 数据模型设计以及接口设计: 定义每一个接口的请求参数和返回部分

3. 接口的注释部分：如何让接口的使用者知道理解如何使用这个接口

4. 接口的版本维护：对于接口的历史版本维护，接口的升级，迁移，下线应该如何处理

5. 系统级别的接口调用设计

## 接口设计的基本原则

接口的基本设计就是一种契约的设计，设计者应该为接口定义正式，准确，可验证的接口规范。这些规范泛称“契约(contracts)”，它是一种比喻，类似于商业契约/合同的条件和职责。

### 单一职责原则

单一性原则是接口的一种基本原则，它要求对于接口的设计应该尽量的简单，做且仅做一件明确的事情。这个职责也就是设计的轴心, 如果有了一个以上的职责，这些职责就耦合在了一起，会导致脆弱的设计。当这一职责发生变化的时候，可能会影响其他的职责。另外，多个职责耦合在一起，会影响复用性。

所以对应的解决方案就是，将职责分散，当功能较多或很大的时候，将大的职责拆分成粒度更小的多个子职责。

比如：如下的接口明显有两类职责，连接管理和数据的通讯

```java
interface Modem {
	void dial(String pno);
    void hangup();
    void send(char c);
    void recv();
}
```

这样如果数据的通讯需要改动就会同步的影响到连接管理的重构

通过如下的适当拆分，可以完成单一职责的改造。
```java
interface DataChannel{
	void send(char c);
    void recv();
}

interface Connection{
    void dial(String pno);
    void hangup();
}
```

这个原则是所有原则中最简单的原则之一， 但同时也是最难正确应用原则之一。我们会不由的把职责以组的方式形成一个类，但软件设计的真正职责也就是把发现这些职责，并把这些职责分离开。

### 隔离性原则

定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。

解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。

举例来说明接口隔离原则：
![[Pasted image 20230227151723.png]]

可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：

![[Pasted image 20230227151753.png]]
接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。

说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单**一职责原则原注重的是职责**；而接口隔离原则注重对接口依赖的隔离。其二，**单一职责原则主要是约束类**，其次才是接口和方法，它针对的是程序中的实现和细节；而**接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建**。

采用接口隔离原则对接口进行约束时，要注意以下几点：

-   接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。
-   为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。
-   提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。

### 开闭原则

(设计模式同样需要此原则)

一个软件实体如类、模块和函数应当对扩大开放，对修改封闭。

现有的接口可以继承下来形成契约，并对修改关闭。但是实现类可以有多个，并实现同一个接口。

实现开闭原则的关键就在于“抽象”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。

### 幂等性

幂等性是分布式系统设计中十分重要的概念，它是指一次和多次请求某一个资源应该具有同样的副作用。

为什么需要幂等性呢？我们先从一个例子说起，假设有一个从账户取钱的远程API，我们暂时用类函数的方式记为

```java
bool withdraw(account_id, amount);
```

withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。

值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。

这个问题的解决方案一是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。

另一种更轻量级的解决方案是幂等设计。上面的withdraw显然不满足幂等性，但我们可以一些技巧将它变成幂等的，比如：

```java
int create_ticket();

bool idempotent_withdraw(ticket_id, account_id, amount);
```

create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。

基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：

1.  调用create_ticket()获取ticket_id；
2.  调用idempotent_withdraw(ticket_id, account_id, amount)。

虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。

和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。

### 分包分类

一个合理的接口设计包含合理的包路径设计和接口拆分设计。

包设计的主要原则包括：

1）包内的内容尽量保持高内聚

2）隐藏细节，尤其是接口实现的细节。在同一个抽奖的层次内尽量只包含接口的定义和同一级别抽象的内容，接口的实现内容应该在其对应实现层的子包中。

3）面向问题域，也就是实际业务领域内的一般组织结构来建包，而不是显得支离破碎。

4）包与包之间应该避免循环依赖，否则应该重新考虑包设计。

5）尽量依赖稳定的包，尤其是接口本身尽量依赖稳定的设计，这意味着依赖的内容难以被改变，从而保证接口本身的稳定。

## 接口的主体部分设计

### 命名

一个好的接口命名绝不是一个简单的事情，需要设计人员耗费大量的时间进行思考和抽象。

在命名时需要遵循一些基本的规则：

1） 名副其实：

接口的命名需要让阅读者一眼可以通过接口的明明读出接口的作用和意义。，不要认为把时间花费在变量的命名上很浪费。当然如果你程序很短的话，就不需要考虑那么多了，埋头就写代码。如果你的项目大，而且文件多的情况下，最好就是要花费时间在命名上，因为你的代码不仅仅只是你一个人看的。

2） 名词或者名词短语：

一个恰当的接口明明应该是名词或者名词短语比如XXXCustomer，XXXBuilder等等

3） 动词或者动词短语：

一个恰当的接口方法应该以动词或者动词短语来进行命名。

4） 命名时尽量清晰明了的词汇组成，每一个概念使用一个词汇，比如getMsg(),getUserName()等等

5） 添加语境：

比如一些简单的含义词汇定义，如cardNo，name如果在适当的语境可以明确其为银行卡卡号，则直接添加语境词汇改为bankCardNo，cardHoderName等，以更清晰表达，并帮助后人理解。

简单来说对于接口名和方法名定义时，首要的选择不是短小，而是要能够清晰的表达出接口的含义。