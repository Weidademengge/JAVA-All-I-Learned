## 什么是原子类

在编程领域里，原子性意味着“一组操作要么全都操作成功，要么全都失败，不能只操作成功其中的一部分”。

而 java.util.concurrent.atomic 下的类，就是具有原子性的类，可以原子性地执行添加、递增、递减等操作。比如之前多线程下的线程不安全的 i++ 问题，到了原子类这里，就可以用功能相同且线程安全的 getAndIncrement() 方法来优雅地解决。

---

## 原子类的作用

**原子类的作用**和锁类似，是为了保证并发情况下线程安全。不过原子类相比于锁，有一定的优势：

-   粒度更细：原子变量可以把竞争范围缩小到变量级别，通常情况下，锁的粒度都要大于原子变量的粒度。
-   效率更高：除了高度竞争的情况之外，使用原子类的效率通常会比使用同步互斥锁的效率更高，因为原子类底层利用了 CAS 操作，不会阻塞线程。

---

## 原子类的分类

### 基本类型

`Atomic*`，我们把它称为基本类型原子类，它包括三种，分别是 [[[AtomicInteger](https://aliyuque.antfin.com/faw-tech/cdgkfq/vqwyowy3vtxh6iel)]]、AtomicLong 和 AtomicBoolean

常用方法：

```java
public final int get() //获取当前的值
public final int getAndSet(int newValue) //获取当前的值，并设置新的值
public final int getAndIncrement() //获取当前的值，并自增 +1
public final int getAndDecrement() //获取当前的值，并自减 -1
public final int getAndAdd(int delta) //获取当前的值，并加上预期的值
boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值更新为输入值（update）
```

---

### 数组类型

`Atomic*Array` 数组类型原子类，数组里的元素，都可以保证其原子性，比如 AtomicIntegerArray 相当于把 AtomicInteger 聚合起来，组合成一个数组。这样一来，我们如果想用一个每一个元素都具备原子性的数组的话， 就可以使用 `Atomic*Array`

它一共分为 3 种，分别是：

-   AtomicIntegerArray：整形数组原子类
-   AtomicLongArray：长整形数组原子类
-   AtomicReferenceArray ：引用类型数组原子类

---

### 引用类型

`AtomicReference` 引用类型原子类。它作用和 AtomicInteger 并没有本质区别， AtomicInteger 可以让一个整数保证原子性，而 AtomicReference 可以让一个对象保证原子性。这样一来，AtomicReference 的能力明显比 AtomicInteger 强，因为一个对象里可以包含很多属性。

它一共分为 3 种，分别是：

-   AtomicReference：原始版
-   AtomicStampedReference：升级版，加了时间戳，用于解决 CAS 的 ABA 问题。
-   AtomicMarkableReference：多了一个绑定的布尔值，可以用于表示该对象已删除等场景。

---

### 更新器

`Atomic*FieldUpdater`，我们把它称为原子更新器。如果我们之前已经有了一个变量，比如是整型的 int，实际它并不具备原子性。可是木已成舟，这个变量已经被定义好了，此时我们有没有办法可以让它拥有原子性呢？办法是有的，就是利用 `Atomic*FieldUpdater`，如果它是整型的，就使用 AtomicIntegerFieldUpdater 把已经声明的变量进行升级，这样一来这个变量就拥有了 CAS 操作的能力。

它一共分为 3 种，分别是：

-   AtomicIntegerFieldUpdater：原子更新整形的更新器
-   AtomicLongFieldUpdater：原子更新长整形的更新器
-   AtomicReferenceFieldUpdater：原子更新引用的更新器

---

### 加法器

-   LongAdder
-   DoubleAdder

在 JDK 8 中新增了 LongAdder 这个类，这是一个针对 Long 类型的操作工具类。那么既然已经有了 AtomicLong，为何又要新增 LongAdder 这么一个类呢？

高并发下 LongAdder 比 AtomicLong 效率更高。因为 LongAdder 引入了分段累加的概念，内部一共有两个参数参与计数：变量 `base` 和数组 `Cell[]`

-   其中的 `base` 是用在竞争不激烈的情况下的，可以直接把累加结果改到 `base` 变量上。
-   一旦竞争激烈，各个线程会分散累加到自己所对应的那个 `Cell[]` 数组的某一个对象中，而不会大家共用同一个。

---

### 积累器

-   LongAccumulator
-   DoubleAccumulator

Accumulator 和 Adder 非常相似，实际上 Accumulator 就是一个更通用版本的 Adder，比如 LongAccumulator 是 LongAdder 的功能增强版，因为 LongAdder 的 API 只有对数值的加减，而 LongAccumulator 提供了自定义的函数操作。

```java
public class LongAccumulatorDemo {
    public static void main(String[] args) throws InterruptedException {
        LongAccumulator accumulator = new LongAccumulator((x, y) -> x + y, 0);
        ExecutorService executor = Executors.newFixedThreadPool(8);
        IntStream.range(1, 10).forEach(i -> executor.submit(() -> accumulator.accumulate(i)));
        Thread.sleep(2000);
        System.out.println(accumulator.getThenReset());
    }
}
```