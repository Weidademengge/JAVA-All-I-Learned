
## 锁特性的分类

根据锁的常见特性，我们把锁分为以下 7 大类别，分别是：

-   偏向锁/轻量级锁/重量级锁
-   可重入锁/非可重入锁
-   共享锁/独占锁
-   公平锁/非公平锁
-   悲观锁/乐观锁
-   自旋锁/非自旋锁
-   可中断锁/不可中断锁

---

这些多种多样的分类，其实是评价一个事物的多种标准。所以对于 Java 中的锁而言，一把锁也有可能同时占有多个标准，符合多种特性分类，比如 ReentrantLock 既是可中断锁，又是可重入锁。

---

### 偏向锁/轻量级锁/重量级锁

-   偏向锁：如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了
-   轻量级锁：是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞状态
-   重量级锁：当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态

这三种锁 `特指 synchronized 锁的状态`，通过在对象头中的 mark word 来表明锁的状态

---

### 可重入锁/非可重入锁

-   可重入锁：指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下再次获取这把锁
-   不可重入锁：指的是虽然线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取

可重入锁，最典型的就是 `ReentrantLock` 了，正如它的名字一样，reentrant 的意思就是可重入，它也是 Lock 接口最主要的一个实现类

---

### 共享锁/独占锁

-   共享锁：指的是同一把锁可以被多个线程同时获得
-   独占锁：指的是同一把锁只能同时被一个线程获得

读写锁 `ReadWriteLock`，就最好地诠释了共享锁和独占锁的理念

---

### 公平锁/非公平锁

-   公平锁：如果线程现在拿不到这把锁，那么线程就都会进入等待，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思
-   非公平锁：它会在一定情况下，忽略掉已经在排队的线程，发生插队现象

我们可以通过改变 `new ReentrantLock(false)` 中的参数来设置公平/非公平锁

---

### 悲观锁/乐观锁

-   悲观锁：是在获取资源之前，必须先拿到锁，以便达到“独占”的状态
-   乐观锁：它并不要求在获取资源前拿到锁，也不会锁住资源。而是利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改

悲观锁：`synchronized` 关键字和 `Lock` 接口乐观锁：原子类，例如 `AtomicLong`  
大喜大悲：数据库

---

### 自旋锁/非自旋锁

-   自旋锁：如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁
-   非自旋锁：就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑

JUC包里面的原子类基本都是自旋锁的实现，例如 `AtomicLong`

---

### 可中断锁/不可中断锁

-   可中断锁：在获取锁的过程中，突然不想获取了，那么可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开
-   不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理

`synchronized` 关键字修饰的锁代表的是不可中断锁`ReentrantLock` 是一种典型的可中断锁，使用 `lockInterruptibly()` 方法在获取锁的过程中进行中断

---

## 锁机制的分类

Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问：

-   JVM 实现的 `synchronized`
-   JDK 实现的 Lock 的实现类，例如 `ReentrantLock`

---

### synchronized

**1. 同步一个代码块**

```java
public void func() {
    synchronized (this) {
        // ...
    }
}
```

它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。

对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。

```java
public class SynchronizedExample {

    public void func1() {
        synchronized (this) {
            for (int i = 0; i < 10; i++) {
                System.out.print(i + " ");
            }
        }
    }
}
```


```java
public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> e1.func1());
    executorService.execute(() -> e1.func1());
}
```
  

```
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```

对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。

```java
public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> e1.func1());
    executorService.execute(() -> e2.func1());
}
```

```
0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9
```

**2. 同步一个方法**

```java
public synchronized void func () {
    // ...
}
```

它和同步代码块一样，作用于同一个对象。

**3. 同步一个类**

```java
public void func() {
    synchronized (SynchronizedExample.class) {
        // ...
    }
}
```

作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。

```java
public class SynchronizedExample {

    public void func2() {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i < 10; i++) {
                System.out.print(i + " ");
            }
        }
    }
}
```

  

```java
public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> e1.func2());
    executorService.execute(() -> e2.func2());
}
```

```
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```

**4. 同步一个静态方法**

```java
public synchronized static void fun() {
    // ...
}
```

作用于整个类。

---

### ReentrantLock

ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。

```java
public class LockExample {

    private Lock lock = new ReentrantLock();

    public void func() {
        lock.lock();
        try {
            for (int i = 0; i < 10; i++) {
                System.out.print(i + " ");
            }
        } finally {
            lock.unlock(); // 确保释放锁，从而避免发生死锁。
        }
    }
}
```

```java
public static void main(String[] args) {
    LockExample lockExample = new LockExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> lockExample.func());
    executorService.execute(() -> lockExample.func());
}
```

```
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```

---

### 比较

**1. 锁的实现**

```java
synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。
```

**2. 性能**

新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。

**3. 等待可中断**

当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。

ReentrantLock 可中断，而 synchronized 不行。

**4. 公平锁**

公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。

synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。

**5. 锁绑定多个条件**

一个 ReentrantLock 可以同时绑定多个 Condition 对象。

---

### 如何选择

最后我们再来看下如何选择它们，在 Java 并发编程实战和 Java 核心技术里都认为：

1.  如果能不用最好既不使用 Lock 也不使用 synchronized。因为在许多情况下你可以使用 java.util.concurrent 包中的机制，它会为你处理所有的加锁和解锁操作，也就是推荐优先使用工具类来加解锁。
2.  如果 synchronized 关键字适合你的程序， 那么请尽量使用它，这样可以减少编写代码的数量，减少出错的概率。因为一旦忘记在 finally 里 unlock，代码可能会出很大的问题，而使用 synchronized 更安全，不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。
3.  如果特别需要 Lock 的特殊功能，比如尝试获取锁、可中断、超时功能等，才使用 Lock。