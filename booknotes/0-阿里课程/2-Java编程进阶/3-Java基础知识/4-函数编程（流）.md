#Java #流编程

---

# 集合与流操作对比

## 代码实践

分别使用集合操作及Stream流操作，完成对实际应用场景中的数据处理。直观感受流操作带来的便捷性。

---

### 新建包名：stream

![](https://lang-image-bed.oss-cn-hangzhou.aliyuncs.com/20230215235453.png)

注意：是测试工程下

---

## 需求场景

1.  想看看购物车中都有什么商品
2.  除了图书类商品都给买
3.  其余的商品中买两件最贵的
4.  只需要两件商品的名称和总价

---

### 集合实现

```java
@Test  
public void oldCartHandle() {  
    List<Sku> cartSkuList = BaseCartService.getCartSkuList();  
  
    // 1 打印所有商品   
    for (Sku sku: cartSkuList) {  
        System.out.println(JSON.toJSONString(sku, true));  
    }  
  
    // 2 图书类过滤掉   
    List<Sku> notBooksSkuList = new ArrayList<Sku>();  
    for (Sku sku: cartSkuList) {  
        if (!SkuCategoryEnum.BOOKS.equals(sku.getSkuCategory())) {  
            notBooksSkuList.add(sku);  
        }  
    }  
  
    // 排序   
    notBooksSkuList.sort(new Comparator<Sku>() {  
        @Override  
        public int compare(Sku sku1, Sku sku2) {  
            if (sku1.getTotalPrice() > sku2.getTotalPrice()) {  
                return -1;  
            } else if (sku1.getTotalPrice() < sku2.getTotalPrice()) {  
                return 1;  
            } else {  
                return 0;  
            }  
        }  
    }
	//(Sku sku1, Sku sku2) -> sku2.getTotalPrice().compareTo(sku1.getTotalPrice())
   	//Comparator.comparing(Sku::getTotalPrice).reversed()                    
    );  
  
    // TOP2
	List<Sku> top2SkuList = new ArrayList<Sku>();  
    for (int i = 0; i < 2; i++) {  
        top2SkuList.add(notBooksSkuList.get(i));  
    }  
  
    // 4 求两件商品的总价    
    Double money = 0.0;  
    for (Sku sku: top2SkuList) {  
        // money = money + sku.getTotalPrice();  
        money += sku.getTotalPrice();  
    }  
  
    // 获取两件商品的名称  
    List<String> resultSkuNameList = new ArrayList<String>();  
    for (Sku sku: top2SkuList) {  
        resultSkuNameList.add(sku.getSkuName());  
    }  
  
    System.out.println(  
            JSON.toJSONString(resultSkuNameList, true));  
    System.out.println("商品总价：" + money);  
}
```

---

### 流实现

```java
@Test  
public void newCartHandle() {  
    AtomicInteger money = new AtomicInteger(0);  
  
    List<String> resultSkuNameList =  
            BaseCartService.getCartSkuList()  
            .stream()  
            // 1 打印商品信息  
            .peek(sku -> System.out.println(  
                    JSON.toJSONString(sku, true)))  
            // 2 过滤掉所有图书类商品  
            .filter(sku -> !SkuCategoryEnum.BOOKS.equals(  
                    sku.getSkuCategory()))  
            // 排序  
            .sorted(Comparator.  
                    comparing(Sku::getTotalPrice).reversed())  
            // TOP2
			.limit(2)  
            // 累加商品总金额  
            .peek(sku -> money.set(money.get() + sku.getTotalPrice()))  
            // 获取商品名称  
            .map(sku -> sku.getSkuName())  
            // 收集结果  
            .collect(Collectors.toList());  
  
    System.out.println(  
            JSON.toJSONString(resultSkuNameList, true));  
    System.out.println("商品总价：" + money.get());  
}
```

---

# 流的介绍

## 什么是流

1.  Java8 引入的新成员，以声明式方式处理集合数据
2.  将基础的操作链接起来，完成复杂的数据处理流水线
3.  提供透明的并行处理

---

## 官方定义

从支持数据处理操作的源生成的元素序列 -- Java8 实战

类似数据库操作

---

## 流与集合的区别

-   时间与空间 （类比：流媒体播放和离线播放）

-   流面向计算，集合面向存储

-   只能遍历一次

-   集合可以遍历多次

-   内部迭代与外部迭代

-   集合需要外部 for-each 来迭代

---

## 流操作的组成

![](https://lang-image-bed.oss-cn-hangzhou.aliyuncs.com/Stream.png)

---

## 流操作的分类

![](https://intranetproxy.alipay.com/skylark/lark/0/2023/jpeg/128606/1677641310247-a7ef81d6-1b14-42c6-9f8f-0725d7b84fbd.jpeg)

---

## 流的使用

### peek

-   [Java stream 中 peek() 的合理用法](https://blog.csdn.net/VoisSurTonChemin/article/details/122378636)
-   peek 主要被用在 debug 用途

---

### filter

filter使用：过滤掉不符合断言判断的数据

```java
public class StreamOperator {  
  
    List<Sku> list;  
  
    @Before  
    public void init() {  
        list = BaseCartService.getCartSkuList();  
    }  
 
    @Test  
    public void filterTest() {  
        list.stream()  
                .filter(sku ->  
                        SkuCategoryEnum.BOOKS  
                                .equals(sku.getSkuCategory()))  
                .forEach(item ->  
                        System.out.println(  
                                JSON.toJSONString(  
                                        item, true)));  
    }
}
```

---

### map

map使用：将一个元素转换成另一个元素

```java
@Test  
public void mapTest() {  
    list.stream()  
            .map(sku -> sku.getSkuName())  
            .forEach(item ->  
                    System.out.println(  
                            JSON.toJSONString(  
                                    item, true)));  
}
```

---

### flatMap

flatMap使用：将一个对象转换成流

```java
@Test  
public void flatMapTest() {  
    list.stream()  
            .flatMap(sku -> Arrays.stream(  
                    sku.getSkuName().split("")))  
            .forEach(item ->  
                    System.out.println(  
                            JSON.toJSONString(  
                                    item, true)));  
}
```

---

### peek

peek使用：对流中元素进行遍历操作，与forEach类似，但不会销毁流元素

```java
@Test  
public void peek() {  
    list.stream()  
            .peek(sku -> System.out.println(sku.getSkuName()))  
            .forEach(item ->  
                    System.out.println(  
                            JSON.toJSONString(  
                                    item, true)));  
}
```

---

### sort

sort使用：对流中元素进行排序，可选则自然排序或指定排序规则。有状态操作

```java
@Test  
public void sortTest() {  
    list.stream()  
            .peek(sku -> System.out.println(sku.getSkuName()))  
            .sorted(Comparator.comparing(Sku::getTotalPrice))  
            .forEach(item ->  
                    System.out.println(  
                            JSON.toJSONString(  
                                    item, true)));  
}
```

---

### distinct

distinct使用：对流元素进行去重。有状态操作

```java
@Test  
public void distinctTest() {  
    list.stream()  
            .map(sku -> sku.getSkuCategory())  
            .distinct()  
            .forEach(item ->  
                    System.out.println(  
                            JSON.toJSONString(  
                                    item, true)));    
}
```

---

### skip

skip使用：跳过前N条记录。有状态操作

```java
@Test  
public void skipTest() {  
    list.stream()  
            .sorted(Comparator.comparing(Sku::getTotalPrice))  
            .skip(3)  
            .forEach(item ->  
                    System.out.println(  
                            JSON.toJSONString(  
                                    item, true)));  
}
```

---

### limit

limit使用：截断前N条记录。有状态操作

```java
@Test  
public void limitTest() {  
    list.stream()  
            .sorted(Comparator.comparing(Sku::getTotalPrice))  
            .skip(2 * 3)   
            .limit(3)  
            .forEach(item ->  
                    System.out.println(  
                            JSON.toJSONString(  
                                    item, true)));  
}
```

---

### allMatch

allMatch使用：终端操作，短路操作。所有元素匹配，返回true

```java
@Test  
public void allMatchTest() {  
    boolean match = list.stream()  
            .peek(sku -> System.out.println(sku.getSkuName()))   
            .allMatch(sku -> sku.getTotalPrice() > 100);  
    System.out.println(match);  
}
```

---

### anyMatch

anyMatch使用：任何元素匹配，返回true

```java
@Test  
public void anyMatchTest() {  
    boolean match = list.stream()  
            .peek(sku -> System.out.println(sku.getSkuName()))  
            .anyMatch(sku -> sku.getTotalPrice() > 100);  
    System.out.println(match);  
}
```

---

### noneMatch

noneMatch使用：任何元素都不匹配，返回true

```java
@Test  
public void noneMatchTest() {  
    boolean match = list.stream()  
            .peek(sku -> System.out.println(sku.getSkuName()))  
            .noneMatch(sku -> sku.getTotalPrice() > 10_000);  
    System.out.println(match);  
}
```

---

### findFirst

findFirst使用：找到第一个

```java
@Test  
public void findFirstTest() {  
    Optional<Sku> optional = list.stream()  
            .peek(sku -> System.out.println(sku.getSkuName()))  
            .findFirst();  
    System.out.println(  
            JSON.toJSONString(optional.get(), true));  
}
```

---

### findAny

findAny使用：找任意一个

```java
@Test  
public void findAnyTest() {  
    Optional<Sku> optional = list.stream()  
            .peek(sku -> System.out.println(sku.getSkuName()))   
            .findAny();  
    System.out.println(  
            JSON.toJSONString(optional.get(), true));  
}
```

---

### max

max使用：求最大值

```java
@Test  
public void maxTest() {  
    OptionalDouble optionalDouble = list.stream()  
            // 获取总价  
            .mapToDouble(Sku::getTotalPrice)  
            .max();  
    System.out.println(optionalDouble.getAsDouble());  
}
```

---

### min

min使用：求最小值

```java
@Test  
public void minTest() {  
    OptionalDouble optionalDouble = list.stream()  
            // 获取总价  
            .mapToDouble(Sku::getTotalPrice)  
            .min();  
    System.out.println(optionalDouble.getAsDouble());  
}
```

---

### count

count使用：求个数

```java
@Test  
public void countTest() {  
    long count = list.stream()  
            .count();  
    System.out.println(count);  
}
```

---

## 流的构建

流的四种构建形式：

-   由数值直接构建流
-   通过数组构建流
-   通过文件生成流
-   通过函数生成流（无限流）

---

### 由数值直接构建流

```java
public class StreamConstructor {  
    @Test  
    public void streamFromValue() {  
        Stream stream = Stream.of(1, 2, 3, 4, 5);  
        stream.forEach(System.out::println);  
    }
}
```

---

### 通过数组构建流

```java
@Test  
public void streamFromArray() {  
    int[] numbers = {1, 2, 3, 4, 5};  
    IntStream stream = Arrays.stream(numbers);  
    stream.forEach(System.out::println);  
}`
```

---

### 通过文件生成流

```java
@Test  
public void streamFromFile() throws IOException {  
    // TODO 此处替换为本地文件的地址全路径  
    String filePath = "";  
    Stream<String> stream = Files.lines(  
            Paths.get(filePath));  
    stream.forEach(System.out::println);  
}
```

---

### 通过函数生成流（无限流）

```java
@Test  
public void streamFromFunction() {  
	// Stream stream = Stream.iterate(0, n -> n + 2);  
	Stream stream = Stream.generate(Math::random);  
	stream.limit(100)  
			.forEach(System.out::println);  
}
```