# 线程池的引入

在测试工程下新建类：

![](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/128606/1677646955080-da5786eb-1c0a-4baf-8200-3c6d8bb7a172.png)

## 实现文档处理需求

```java
@Test  
public void oldHandle() throws InterruptedException {  
    for (int i = 0; i < 100; i++) {  
        new Thread(() -> {  
            System.out.println("文档处理开始！");  
  
            try {  
                Thread.sleep(1000l * 30);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
            System.out.println("文档处理结束！");  
        }).start();  
    }  
  
    Thread.sleep(1000l * 1000);  
}
```

---

## 运行结果

![](https://lang-image-bed.oss-cn-hangzhou.aliyuncs.com/20230219190126.png)

---

## 优化文档处理需求

```java
@Test  
public void newHandle() throws InterruptedException {  
    // 开启了一个线程池：线程个数是10个  
    ExecutorService threadPool =  
            Executors.newFixedThreadPool(10);  
  
    for (int i = 1; i <= 100; i++) {  
        threadPool.execute(() -> {  
            System.out.println("文档处理开始！");  
  
            try {  
                // 将Word转换为PDF格式：处理时长很长的耗时过程  
                Thread.sleep(1000L * 30);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
            System.out.println("文档处理结束！");  
        });  
    }  
  
    Thread.sleep(1000L * 1000);  
}
```

---

## 运行结果

![](https://lang-image-bed.oss-cn-hangzhou.aliyuncs.com/20230219225341.png)

---

# 线程池的介绍

## 什么是线程池

线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自己创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程的开销。

---

## 池化技术的优势

-   降低资源消耗
-   提高响应速度
-   提高资源的可管理性

---

## 简单线程池设计

面试题：你能独立设计出一个简单线程池吗？

---

### 第一版设计

1.  首先，得有一个池子
2.  提供者

	1.  初始化池子

3.  使用者

	1.  从池中获取线程
	2.  往池中归还线程

---

### 第二版设计

1.  首先，得有一个池子
2.  使用者

	1.  提交任务
	2.  获取结果

3.  提供者

	1.  初始化池子
	2.  构建任务队列
	3.  获取线程，执行任务
	4.  执行完毕，归还线程
	5.  返回异步结果

---

### 设计过程中要思考的问题

1.  初始创建多少线程？
2.  没有可用线程了怎么办？
3.  缓冲数组要多长？
4.  缓冲数组满了怎么办？

---

# 线程池的学习

## 核心参数

-   corePoolSize
-   maximumPoolSize
-   keepAliveTime
-   unit
-   workQueue
-   threadFactory
-   handler

---

## 处理流程

![](https://lang-image-bed.oss-cn-hangzhou.aliyuncs.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png)

---

## 可选择的阻塞队列

-   什么是阻塞队列？
-   阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：

-   在队列为空时，获取元素的线程会等待队列变为非空。
-   当队列为满时，存储元素的线程会等待队列变为可用。

-   线程池提供了哪些选择

-   有界队列
-   无界队列
-   同步移交队列

---

### 有界队列

```java
@Test
public void arrayBlockingQueue() throws InterruptedException {  
    // 基于数组的有界阻塞队列，队列容量为10  
    ArrayBlockingQueue queue =  
            new ArrayBlockingQueue<Integer>(10);  
  
    // 循环向队列添加元素  
    for (int i = 0; i < 20; i++) {  
        queue.put(i);  
        System.out.println("向队列中添加值：" + i);  
    }  
}
```

---

### 无界队列

```java
@Test
public void linkedBlockingQueue() throws InterruptedException {  
    // 基于链表的有界/无界阻塞队列  
    LinkedBlockingQueue queue =  
            new LinkedBlockingQueue<Integer>();  
  
    // 循环向队列添加元素  
    for (int i = 0; i < 20; i++) {  
        queue.put(i);  
        System.out.println("向队列中添加值：" + i);  
    }  
}
```

---

### 同步移交队列

```java
@Test  
public void synchronousQueue() throws InterruptedException {  
    // 同步移交阻塞队列  
    SynchronousQueue queue = new SynchronousQueue<Integer>();  
  
    // 插入值  
    new Thread(() -> {  
        try {  
            queue.put(1);  
            System.out.println("插入成功！");  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }).start();  
      
    // 删除值  
    new Thread(() -> {  
        try {  
            queue.take();  
            System.out.println("删除成功！");  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }).start();  
  
    Thread.sleep(1000L * 60);  
}
```

---

## 可选择的饱和策略

-   AbortPolicy 终止策略（默认）
-   DiscardPolicy 抛弃策略
-   DiscardOldestPolicy 抛弃旧任务策略
-   CallerRunsPolicy 调用者运行策略

---

### 终止策略

```java
package com.ebanma.cloud.threadpool;  
  
import org.junit.After;  
import org.junit.Test;  
  
import java.util.concurrent.LinkedBlockingQueue;  
import java.util.concurrent.ThreadPoolExecutor;  
import java.util.concurrent.TimeUnit;  
  
public class PolicyTest {  
   
    private static ThreadPoolExecutor executor =  
            new ThreadPoolExecutor(  
                    // 核心线程数和最大线程数  
                    2, 3,  
                    // 线程空闲后的存活时间  
                    60L, TimeUnit.SECONDS,  
                    // 有界阻塞队列  
                    new LinkedBlockingQueue<Runnable>(5));  
   
    class Task implements Runnable {  
        // 任务名称  
        private String taskName;  
  
        public Task(String taskName) {  
            this.taskName = taskName;  
        }  
  
        @Override  
        public void run() {  
            System.out.println("线程[ " + Thread.currentThread().getName()  
                    + " ]正在执行[ " + this.taskName + " ]任务...");  
  
            try {  
                Thread.sleep(1000L * 5);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
  
            System.out.println("线程[ " + Thread.currentThread().getName()  
                    + " ]已执行完[ " + this.taskName + " ]任务！！！");  
        }  
    }  
  
    /**  
     * 线程池的执行过程  
     *  
     * 2个核心线程  
     * 5个任务的队列  
     * 3个最大线程：1个线程可用  
     *  
     * 前2个任务，会占用2个核心线程  
     * 第3个到第7个任务，会暂存到任务队列中  
     * 第8个任务，会启动最大线程，去执行  
     * 第9个任务，没有线程可以去执行~~~  
     */   
    @Test  
    public void abortPolicyTest() {  
        // 设置饱和策略为 终止策略  
        executor.setRejectedExecutionHandler(  
                new ThreadPoolExecutor.AbortPolicy());  
  
        for (int i = 1; i <= 10; i++) {  
            try {  
                // 提交10个线程任务  
                executor.execute(new Task("线程任务" + i));  
            } catch (Exception e) {  
                System.err.println(e);  
            }  
        }  
  
        // 关闭线程池  
        executor.shutdown();  
    }  
  
    /**  
     * 单元测试执行完，主线程等待100秒。防止主线程退出，看不到线程的执行结果  
     * @throws InterruptedException  
     */  
    @After  
    public void after() throws InterruptedException {  
        Thread.sleep(1000L * 100);  
    }  
  
}
```

---

### 抛弃策略

```java
@Test  
public void discardPolicyTest() {  
    // 设置饱和策略为 抛弃策略  
    executor.setRejectedExecutionHandler(  
            new ThreadPoolExecutor.DiscardPolicy());  
  
    for (int i = 1; i <= 10; i++) {  
        try {  
            // 提交10个线程任务  
            executor.execute(new Task("线程任务" + i));  
        } catch (Exception e) {  
            System.err.println(e);  
        }  
    }  
  
    // 关闭线程池  
    executor.shutdown();  
}
```

---

### 抛弃旧任务策略

```java
@Test  
public void discardOldestPolicyTest() {  
    // 设置饱和策略为 抛弃旧任务策略  
    executor.setRejectedExecutionHandler(  
            new ThreadPoolExecutor.DiscardOldestPolicy());  
  
    for (int i = 1; i <= 10; i++) {  
        try {  
            // 提交10个线程任务  
            executor.execute(new Task("线程任务" + i));  
        } catch (Exception e) {  
            System.err.println(e);  
        }  
    }  
  
    // 关闭线程池  
    executor.shutdown();  
}
```

---

### 调用者运行策略

```java
@Test  
public void callerRunsPolicyTest() {  
    // 设置饱和策略为 调用者运行策略  
    executor.setRejectedExecutionHandler(  
            new ThreadPoolExecutor.CallerRunsPolicy());  
  
    for (int i = 1; i <= 10; i++) {  
        try {  
            // 提交10个线程任务  
            executor.execute(new Task("线程任务" + i));  
        } catch (Exception e) {  
            System.err.println(e);  
        }  
    }  
  
    // 关闭线程池  
    executor.shutdown();  
}
```

---

## 执行示意图

![](https://lang-image-bed.oss-cn-hangzhou.aliyuncs.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

---

## 常用线程池

### 线程数量无限线程池

```java
public static ExecutorService newCachedThreadPool() {  
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,  
                     60L, TimeUnit.SECONDS,  
                     new SynchronousQueue<Runnable>());  
}
```

---

### 线程数量固定线程池

```java
public static ExecutorService newFixedThreadPool(int nThreads) {  
    return new ThreadPoolExecutor(nThreads, nThreads,  
                     0L, TimeUnit.MILLISECONDS,  
	                 new LinkedBlockingQueue<Runnable>());  
}
```

---

### 单一线程线程池

```java
public static ExecutorService newSingleThreadExecutor() {  
    return new FinalizableDelegatedExecutorService  
        (new ThreadPoolExecutor(1, 1,  
                       0L, TimeUnit.MILLISECONDS,  
                       new LinkedBlockingQueue<Runnable>()));  
}
```
---

## 向线程池提交任务

### 方法一 submit

```java
@Test  
public void submitTest()  
        throws ExecutionException, InterruptedException {  
  
    // 创建线程池  
    ExecutorService threadPool =  
            Executors.newCachedThreadPool();  
  
    // 利用submit方法提交任务，接收任务的返回结果   
    Future<Integer> future = threadPool.submit(() -> {  
        Thread.sleep(1000L * 10);  
        return 2 * 5;  
    });  
  
    // 阻塞方法，直到任务有返回值后，才向下执行  
    Integer num = future.get();  
    System.out.println("执行结果：" + num);  
}
```

---

### 方法二 execute

```java
@Test  
public void executeTest() throws InterruptedException {  
    // 创建线程池  
    ExecutorService threadPool =  
            Executors.newCachedThreadPool();  
  
    // 利用execute方法提交任务，没有返回结果   
    threadPool.execute(() -> {  
        try {  
            Thread.sleep(1000L * 10);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
        Integer num = 2 * 5;  
        System.out.println("执行结果：" + num);  
    });  
  
    Thread.sleep(1000L * 1000);  
}
```

---

## 线程池的状态

![](https://lang-image-bed.oss-cn-hangzhou.aliyuncs.com/20230219221650.png)

---

## 多线程的调试

-   多线程同时运行时，谁先执行，谁后执行，完全是看 CPU 心情的，无法控制先后，运行时可能没什么问题，但是调试时就比较麻烦了，最明显的就是断点乱跳
-   如果想让线程在调试时，想按自己的愿意来，让它停在哪个线程就停在哪个线程，可以在断点的小红点上右击，选择 Suspend 挂起的条件是 Thread，而非 All。

---

## 创建线程池的正确姿势

避免使用 Executors 创建线程池，主要是避免使用其中的默认实现，那么我们 可以自己直接调用 ThreadPoolExecutor 的构造函数来自己创建线程池。在创建的 同时，给 BlockQueue 指定容量就可以了。

```java
private static ExecutorService executor = new ThreadPoolExecutor(10, 10, 
        60L, TimeUnit.SECONDS,
		new ArrayBlockingQueue(10));
```

这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出 java.util. concurrent.RejectedExecutionException，这是因为当前线程池使用的队列是有边界队列，队列已经满了便无法继续处理新的请求。但是异常(Exception)总比 发生错误(Error)要好。

### 最佳实践

推荐使用 guava 提供的 ThreadFactoryBuilder 来创建线程池

```java
public class ExecutorsDemo {
    private static ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat("demo-pool-%d").build();
    private static ExecutorService pool = new ThreadPoolExecutor(5, 200, 
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>(1024), 
                            namedThreadFactory, 
                            new ThreadPoolExecutor.AbortPolicy());
    
    public static void main(String[] args) {
        for (int i = 0; i < Integer.MAX_VALUE; i++) { 
            pool.execute(() -> System.out.println(Thread.currentThread().getName()));
        }
    }
}
```