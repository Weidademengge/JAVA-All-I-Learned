# 功能：在运行中分析类的能力

简单说就是：只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。

## Class类
  
java运行时系统始终为所有对象维护一个被称为运行时的类型标识。这个信息跟踪每一个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。  

保存这些信息的类称为Class。

### 1.Class的特点
  
（1）没有公共构造方法，Class对象是加载类时由虚拟机以及调用类加载器中的defineClass方法构造的，不能显式声明。  
（2）每种类型都有唯一一个Class对象。  
（3）基本类型（int、long、short、float、double、char、byte、boolean）以及void也都对应一个class对象。  
（4）相同元素类型和维数的数组拥有同一个class对象。

### 2.获取Class对象
  
（1）Object类中的getClass方法，如：Date d = new Date(); Class c1 = d.getClass();  
（2）Class类中的静态方法forName，如：Class c2 = Class.forName("java.util.Date");  
（3）设T是一个java类型，则，T.class代表其对应的Class对象，如：Date.class，Double[].class

### 3.Class类的常用方法
  
（1）getName()  
返回Class类对应实体（类、接口、数组、基本类型、void）的名称，如：  
java.util.Date.class.getName()返回“java.util.Date”  
对于数组，返回的名字会比较奇怪，如：Double[].class.getName()返回“[Ljava.lang.Double;”  
int[].class.getName()返回“[I”
  
（2）newInstance()  
Date.class.newInstance()会返回一个Date实例，相当于new Date()，该方法会调用类的无参构造器，如果没有无参构造器会抛出异常。
  
（3）getComponentType()  
返回数组组件类型的Class。比如Double[].class.getComponentType()会返回一个Double.class
  
（4）getSuperclass()  
返回Class对应实体的超类的Class
  
（5）isArray()  
判断Class对应的实体是不是一个数组。

## ClassLoader类

### 1. classloader

classloader用来加载Class文件到JVM，以供程序使用的。java程序可以动态加载类定义，而这个动态加载的机制就是通过ClassLoader来实现的。

#### （1）bootstrap classloader

既然ClassLoader是用来加载类到JVM中的，那么ClassLoader又是如何被加载呢？  
这是因为存在一个ClassLoader不是用java语言所编写的，而是JVM实现的一部分，这个ClassLoader就是bootstrap classloader（启动类加载器）。

这个bootstrap classloader在JVM运行的时候加载java核心的API以满足java程序最基本的需求，其中就包括用户定义的ClassLoader（这里所谓的用户定义是指通过java程序实现的ClassLoader），一个是ExtClassLoader，一个是AppClassLoader。

#### （2）ExtClassLoader

ExtClassLoader，这个ClassLoader是用来加载java的扩展API的，也就是/lib/ext中的类；

#### （3）AppClassLoader

AppClassLoader，这个ClassLoader是用来加载用户机器上CLASSPATH设置目录中的Class的，通常在没有指定ClassLoader的情况下，程序员自定义的类就由AppClassLoader进行加载。

### 2. 一个程序最基本的类加载流程

当运行一个程序的时候，JVM启动，运行bootstrap classloader，该ClassLoader加载java核心API（ExtClassLoader和AppClassLoader也在此时被加载），然后调用ExtClassLoader加载扩展API，最后AppClassLoader加载CLASSPATH目录下定义的Class，这就是一个程序最基本的加载流程。

![](https://intranetproxy.alipay.com/skylark/lark/0/2022/png/128606/1652972474634-69e0692a-6d1c-4143-81c8-253b1dea39dc.png)

### 3.ClassLoader使用双亲委托模式进行类加载

请额外去学习什么是双亲委托模式？

参考资料：[http://www.iteye.com/topic/83978](http://www.iteye.com/topic/83978?spm=ata.21736010.0.0.3fcc51b6O8Nm0n)

### 4.补充介绍

Class.forName(String className) 与ClassLoader.loadClass(String className)的区别？

-   Class.forName(String className) ：加载类，并且执行类初始化
-   ClassLoader.loadClass(String className)：仅仅加载类，不执行类初始化

可以通过Class.forName(String name, boolean initialize, ClassLoader loader) 第二个参数的赋值，来选择是否初始化类。className是所需类的完全限定名

## 利用反射分析类的能力
  
在java.lang.reflect包中有三个类Field、Method、Constructor，分别用于描述类的域、方法、构造器。
  
Class类中的getFields、getMethods、getConstructors分别返回类的public域、方法、构造器数组，包括超类中的公有成员。getDeclaredFields、getDeclaredMethods、getDeclaredConstructors返回类的全部域、方法、构造器，包括私有和受保护成员，不包括超类成员。

### 1.Filed中的方法

getName()返回域的名称  
getType()返回域的类型的Class  
getModifiers()返回public、static、final等修饰符的使用情况，用Modifier中的静态方法解析

### 2.Method中的方法

getName()返回方法名  
getReturnType()返回方法返回值类型对应的Class  
getModifiers()同上  
getParameterTypes()返回传入参数类型对应的Class数组  
getExceptionTypes()返回方法抛出的异常对应的Class数组

### 3.Constructors中的方法

getName()返回构造器名称  
getModifiers()同上  
getParameterTypes()同上  
getExceptionTypes()同上

## 运行时使用反射分析对象

这段代码演示了如何在运行时查看和修改对象某个域的值，其中setAccessible用于修改权限，因为类A中的域a是私有域，直接访问会抛出异常。

```java
import java.lang.reflect.*;

class A {
    private int a;
    public int b;
    public A(int a,int b) {
        this.a = a;
        this.b = b;
    }
}

public class Main {

    public static void main(String[] args) throws Exception {
        Class cl = A.class;
        A z = new A(1,2);
        Field f1 = cl.getDeclaredField("a");
        Field f2 = cl.getField("b");
        System.out.println(f2.get(z));
        
        // 其中setAccessible用于修改权限，因为类A中的域a是私有域，直接访问会抛出异常。
        f1.setAccessible(true);
        System.out.println(f1.get(z));        
        f1.set(z, 3);        
        System.out.println(f1.get(z));
    }

}
```

## 利用反射调用方法

```java
import java.lang.reflect.*;

class A {
    private int a;
    public int b;
    public A(int a,int b) {
        this.a = a;
        this.b = b;
    }
    public void addA(int x) {
    	this.a+=x;
    }
    public int aPlusb() {
    	return a+b;
    }
    public int getA() {
    	return this.a;
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        Class cl = A.class;
        A z = new A(1,2);
        Method f1 = cl.getMethod("addA", int.class);
        Method f2 = cl.getMethod("aPlusb");
        Method f3 = Math.class.getMethod("sqrt", double.class);
        System.out.println(z.getA());
        f1.invoke(z, 10);
        System.out.println(z.getA());
        System.out.println(f2.invoke(z));
        System.out.println(f3.invoke(null, 25.0));
    }
}
```

输出为：  

```
1  
11  
13  
5.0
```
  
# **原理：JDK反射实现**

## 题外话

当我们在IDE中编写代码的时候，打一个点号，IDE会自动弹出对应的属性和方法名，当我们在debug的时候，IDE会将方法运行时方法内局部变量和外部实例上属性的值都展示出来，spring中的IOC和AOP，以及一个RPC框架中，我们反序列化，consumer的代理，以及provider的调用都会用到java的反射功能，有人说使用反射会慢，那么到底慢在哪里呢？

## 反射类图

反射使JAVA语言有了动态编译的功能，也就是在我们编码的时候不需要知道对象的具体类型，但是在运行期可以通过Class.forName()获取一个类的class对象，在通过newInstance获取实例。

先看下java.lang.reflect包下的几个主要类的关系图，当然动态代理的工具类也在该包下。

![](https://intranetproxy.alipay.com/skylark/lark/0/2022/png/128606/1652969362713-bca6b90b-82fe-4887-a7f5-e0f582564442.png)

-   AnnotatedElement

作为顶级接口，这个接口提供了获取注解相关的功能，我们在方法，类，属性，构造方法上都可以加注解，所以下面的Field，Method，Constructor都有实现这个接口，以下是我们经常用的两个方法，jdk8以后,接口里面可以通过default修饰方法实现了

-   GenericDeclaration

提供了获取泛型相关的功能，只有方法和构造方法上支持泛型，所以只有Method，Constructor实现了该接口

-   Member

作为一个对象内部方法和属性的声明的抽象，包含了名称，修饰符，所在的类,其中修饰符包含了 static final public private volatile 等，通过一个整数表示，每一个类型在二进制中占一个位

-   AccessibleObject

这是一个类，提供了权限管理的功能，例如是否允许在反射中在外部调用一个private方法，获取一个private属性的值，所以method，constructor,field都继承该类，下面这段代码展示了如何在反射中访问一个私有的成员变量，class对象的构造方法不允许对外

## 反射为什么慢

经过JDK8优化，其实反射的效率并不慢，在某些情况下可能达到和直接调用基本相同的效率，但是在首次执行或者没有缓存的情况下还是会有性能上的开销，主要在以下方面：

1.  Class.forName(); 会调用本地方法，我们用到的method和field都会在此时加载进来，虽然会进行缓存，但是本地方法免不了有JAVA到C+=在到JAVA得转换开销
2.  class.getMethod()，会遍历该class所有的公用方法，如果没匹配到还会遍历父类的所有方法，并且getMethods()方法会返回结果的一份拷贝，所以该操作不仅消耗CPU还消耗堆内存，在热点代码中应该尽量避免，或者进行缓存
3.  invoke参数是一个object数组，而object数组不支持java基础类型，而自动装箱也是很耗时的

## 反射的运用

### Spring IoC

spring加载bean的流程基本都用到了反射机制  
1. 获取类的实例 通过构造方法getInstance（静态变量初始化，属性赋值，构造方法）  
2. 如果实现了BeanNameAware接口，则用反射注入bean赋值给属性  
3. 如果实现了BeanFactoryAware接口，则设置 beanFactory  
4. 如果实现了ApplicationContextAware，则设置ApplicationContext  
5. 调用BeanPostProcesser的预先初始化方法  
6. 如果实现了InitializingBean,调用AfterPropertySet方法  
7. 调用定制的 init-method()方法 对应的直接 @PostConstruct  
8. 调用BeanPostProcesser的后置初始化完毕的方法

### 序列化fastjson

# 动态代理

JDK 提供了一个工具类来动态生成一个代理，允许在执行某一个方法时进行额外的处理

```java
Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)

class HWInvocationHandler implements InvocationHandler{
    //目标对象
    private Object target;
    
    public HWInvocationHandler(Object target){
        this.target = target;
    }
    
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("------插入前置通知代码-------------");
        //执行相应的目标方法
        Object rs = method.invoke(target,args);
        System.out.println("------插入后置处理代码-------------");
        return rs;
    }
}
```

我们分析下这个方法的实现，首先生成的代理对象，需要实现参数里面声明的所有接口，接口的实现应给委托给 **InvocationHandler** 进行处理，InvocationHandler 里面可以根据 method 声明判断是否需要做增强，所以所生成的代理类里面必须能够获取到 InvocationHandler，在我们无法知道代理类的具体类型的时候，我们可以通过反射从构造方法里将InvocationHandler传给代理类的实例

  
所以总的来说生成代理对象需要两步  
1. 获取代理类的class对象  
2. 通过class对象获取构造方法，通过反射生成代理类的实例，并将InvocationHandler传人

```java
@CallerSensitive
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h)
    throws IllegalArgumentException {
    
    Objects.requireNonNull(h);

    final Class<?>[] intfs = interfaces.clone();

    /*
     * Look up or generate the designated proxy class.
     * 生成代理类
     */
    Class<?> cl = getProxyClass0(loader, intfs);

    /*
     * Invoke its constructor with the designated invocation handler.
     */
    try {
        //获取代理类的构造方法
        final Constructor<?> cons = cl.getConstructor(constructorParams);
        final InvocationHandler ih = h;
        
        if (!Modifier.isPublic(cl.getModifiers())) {
            AccessController.doPrivileged(new PrivilegedAction<Void>() {
                public Void run() {
                    cons.setAccessible(true);
                    return null;
                }
            });
        }
        //获取代理类的实例,并且将invocationhandler传人
        return cons.newInstance(new Object[]{h});
        
    } catch (IllegalAccessException|InstantiationException e) {
       ...
    }
}
```

  
下面我们在看下 getProxyClass0 如何获取代理类的class对象，这里idk通过WeakCache来缓存已经生成的class对象，因为生成该class通过字节码生成还是很耗时，同时为了解决之前由于动态代理生成太多class对象导致内存不足，所以这里通过弱引用WeakReference来缓存所生成的代理对象class，当发生GC的时候如果该class对象没有其他的强引用将会被直接回收

  
生成代理类的class在ProxyGenerator的generateProxyClass方法内实现，该方法返回一个byte[]数组，最后通过一个本地方法加载到虚拟机，所以可以看出生成该对象还是非常耗时的

```java
`//生成字节码数组
byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
    proxyName, interfaces, accessFlags);
try {
//加载进虚拟机
    return defineClass0(loader, proxyName,
                        proxyClassFile, 0, proxyClassFile.length);
} catch (ClassFormatError e) {
    /*
     * A ClassFormatError here means that (barring bugs in the
     * proxy class generation code) there was some other
     * invalid aspect of the arguments supplied to the proxy
     * class creation (such as virtual machine limitations
     * exceeded).
     */
    throw new IllegalArgumentException(e.toString());
}

private byte[] generateClassFile() {
    this.addProxyMethod(hashCodeMethod, Object.class);
    this.addProxyMethod(equalsMethod, Object.class);
    this.addProxyMethod(toStringMethod, Object.class);
    Class[] var1 = this.interfaces;
    int var2 = var1.length;

    int var3;
    Class var4;
    for(var3 = 0; var3 < var2; ++var3) {
        var4 = var1[var3];
        Method[] var5 = var4.getMethods();
        int var6 = var5.length;

        for(int var7 = 0; var7 < var6; ++var7) {
            Method var8 = var5[var7];
            this.addProxyMethod(var8, var4);
        }
    }

    this.methods.add(this.generateConstructor());
...
 }
 //生成一个带invocationhandler参数的构造方法
private ProxyGenerator.MethodInfo generateConstructor() throws IOException {
    ProxyGenerator.MethodInfo var1 = new ProxyGenerator.MethodInfo("<init>", "(Ljava/lang/reflect/InvocationHandler;)V", 1);
    DataOutputStream var2 = new DataOutputStream(var1.code);
    this.code_aload(0, var2);
    this.code_aload(1, var2);
    var2.writeByte(183);
    var2.writeShort(this.cp.getMethodRef("java/lang/reflect/Proxy", "<init>", "(Ljava/lang/reflect/InvocationHandler;)V"));
    var2.writeByte(177);
    var1.maxStack = 10;
    var1.maxLocals = 2;
    var1.declaredExceptions = new short[0];
    return var1;
}`
```

上面的流程可以简单归纳为  
1. 增加hashcode、equals、toString方法  
2. 增加所有接口中声明的未实现方法  
3. 增加一个方法参数为java/lang/reflect/InvocationHandler的构造方法  
4. 其他静态初始化数据

## 动态代理的应用

### Spring AOP

Spring AOP 默认基于jdk动态代理来实现，我们来看下下面这个经典的面试问题：

_一个类里面，两个方法A和方法B，方法B上有加注解做事务增强，那么A调用this.B为什么没有事务效果？_

因为 Spring AOP 默认基于jdk的动态代理实现，最终执行是通过生成的代理对象的，而代理对象执行A方法和B方法其实是调用的InvocationHandler里面的增强后的方法；

其中B方法是经过InvocationHandler做增强，在方法前后增加了事务开启和提交的代码，而真正执行代码是通过methodB.invoke(原始对象)；  
而A方法的实现内部虽然包含了this.B方法，但其实是调用了methodA.invoke(原始对象)，而这一句代码相当于调用的是原始对象的methodA方法，而这里面的this.B()方法其实是调用的原始对象的B方法，没有进行过事物增强，而如果是通过cglib做字节码增强，生成这个类的子类，这种调用this.B方法是有事务效果的。

![](https://intranetproxy.alipay.com/skylark/lark/0/2022/png/128606/1652970832824-51e226c0-66e6-4818-85db-934d3620a74c.png)

### RPC

有过RMI开发经验的人可能会很熟悉，为什么在对外export RMI服务的时候会分别在client和server生成两个stub文件，其中client的文件其实就是用动态代理生成了一个代理类  
这个代理类实现了所要对外提供服务的所有接口，每个方法的实现其实就是将接口信息、方法声明、参数、返回值信息通过网络发给服务端，而服务端收到请求后通过找到对应的实现，然后用反射method.invoke 进行调用，然后将结果返回给客户端；

其实其他的RPC框架的实现方式大致和这个类似，只是客户端的代理类，可能不仅要将方法声明通过网络传输给服务提供方，也可以做一下服务路由、负载均衡、以及传输一些额外的attachment数据给provider