# 原始需求

先看看需求的原始场景，我们在电脑A的进程，想要发一段数据到电脑B的进程。这里涉及到数据传输，首先需要抉择的当然是传输层的协议，TCP or UDP。TCP可靠，UDP 不可靠，这不是本文讨论的重点，且先无脑选TCP，后文需要相关知识推论，先略伏笔。

代码实现，简单入门场景，我们可以用 socket 进行编程。socket 本质上就是个代码库，我们需要先创建它：

```java
fd = socket(AF_INET, SOCK_STREAM, 0);
```

这其中有个 SOCK_STREAM，它是指使用字节流传输，其实就是 TCP 协议。在定义了 socket 之后，程序里就可以使用这个 socket 进行传输操作了，比如：

1）用 bind() 方法绑定IP端口，

2）用 connect() 方法简历连接，

3）用 send() 和 recv() 方法发送和接受数据。

这个过程就是我们经典的 TCP 三次握手过程：_【图一：三次握手和四次挥手】_[[TCP三次握手和四次挥手]]

![[1676955672331-e23f4144-11f7-4b22-9fef-a5cd2064abed.png]]

# 为什么需要协议

看起来，似乎问题已经解决了？**主机 A** 已经可以使用 socket 跟**主机 B** 进行数据传输了。用这套方案，我们的原始需求是不是就足够解决了呢？这么问，当然就是不够啦！此次，我们先回忆一下_**八股文里 TCP 面试经典问题：**_

_**TCP 的三个特点：面向连接，可靠的，基于字节流的**_。

本文需要推论的场景里，主要涉及的是TCP基于字节流这个特点。我们上面用 socket 建立的这套通讯通道其实就是一个双向的流淌着数据的通道，这个数据就是我们常见的**二进制数据**，即01串。上文 socket 纯 TCP 收发的这些01串之间是没有任何边界的，根本无从知道到哪个地方才算是一条完整消息。举个例子，如果我们选择使用纯 TCP 发送，阿里裁员不开心，接手端收到的就是阿里裁员不开心，这时候，接收端没法区分你要是想表达：

-   阿里 裁员不开心，还是
-   阿里裁员不 开心

这就是所谓的**粘包问题**。为了解决这个问题，我们需要做的**就是在纯传递01串的基础上，加一些自定义的规则，用于区分消息边界**，比如加入消息头，里面写清楚一个完整的包长度是多少。那么，**我们把收到的01串数据和包长度结合来截取数据，得到的就是我们真正想要传递的消息体了**。除了包长度之外，额外增加的消息头里，还可以放其他规则，比如消息是否被压缩过，消息格式等等。这，就是所谓的**协议**！

基于 TCP 的项目，都可以定义一套类似这样的协议，解析标准，不同协议内容各有差异，但是原理都类似。基于 TCP，衍生了非常多的协议，比如本文重点讨论的 **HTTP** 和 **RPC**。**TCP 是传输层的协议**，基于 TCP 的 HTTP 和各类 RPC 协议，他们主要是定义了不同消息格式的**应用层协议**。

_【图二：OSI开放式系统互联七层协议】_
![[1676956118649-873f46ba-4ddd-44b5-a5c7-de3a8b4fec92 1.png]]

图示七层协议，不是本文讨论重点，具体内容不展开，主要涉及：

|               |                                                                                                                                                                                                                                                                                   |
|:------------- |:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 第七层 应用层 | 针对特定应用的协议(如，电子邮件协议 E-Mail，远程登录协议 SSH，文件传输协议 FTP，网络请求协议 HTTP)                                                                                                                                                                                |
| 第四层 传输层 | 有了 MAC 地址和 IP 地址，我们还需要一个参数，表示这个数据包到底供哪个程序(进程)使用(比如是浏览器还是钉钉)，这个参数就叫做“端口”，**传输层的功能，就是建立端口到端口的通信**。相比之下，**网络层的功能是建立主机到主机的通信**。只要确定了主机和端口，我们就能实现程序之间的交流。 |
HTTP 就是第七层应用层典型的特定应用协议，又叫做超文本传输协议（Hypertext Transfer Protocol）。也是我们日常使用体感较多的协议，比如平时上网，在浏览器上敲出网址就能访问网页，这里用到的就是 HTTP 协议。而 **RPC** Remote Procedure Call ，又叫做远程过程调用，它本身并不是一个具体的协议，而是一种调用方式。举个例子，我们平时调用一个本地方法 （ _res = localService(req)_ ）使用一个叫 **localService** 的函数，传入 req 参数，输出 req 参数。如果现在这不是个本地方法，而是个远端服务器暴露出的一个方法，**remoteService**, 如果还能像调用本地方法那样去调用它，这样就可以**屏蔽掉一些网络细节**，用起来更方便。说白了，**RPC就是希望像调用本地方法那样去调用远端方法**。基于这个思路，各大厂造了非常多款RPC协议，比如比较有名的MotanRPC，gRPC，Thrift，brpc，srpc 等

# 思考题来了

## 为什么有了 HTTP 协议之后还需要 RPC 协议？
![[1676956118649-873f46ba-4ddd-44b5-a5c7-de3a8b4fec92 2.png]]

这里有个有趣的事情是，回到时间线上看，RPC 出现的时间，实际是早于普遍使用的 HTTP 1.X 版本。那这样，实际我们探讨其实应该是为什么有了 RPC 协议之后还需要 HTTP 协议？请大家先思考！

先提供两个协议的样例，供大家思考！

-   HTTP 协议样例

![[1676956603971-49f97197-9ad7-4069-9457-c5ed3e20c2a0.png]]
-   RPC 协议样例
![[1676956612531-b4696103-04b3-4569-8514-1943c0f9efff 1.png]]
